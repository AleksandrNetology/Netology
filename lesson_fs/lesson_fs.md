### Файловые системы

![](https://upload.wikimedia.org/wikipedia/commons/f/fb/The_Linux_Storage_Stack_Diagram.svg)

На картинке, всё, что находится выше Applications (process) и включая - это `user space`.\
Всё что ниже - `kernel space`.

Стрелочки, подписанные `read(2)`, `write(2)`, `stat(2)` и т.д. это системные вызовы, инфу по ним можно посмотреть во 2-м разделе `man`.

Из схемы видно, что приложения взаимодействуют с VFS - это такая подсистема ядра, которая реализует интерфейс взаимодействия пользовательских
приложений с различными файловыми системами. Более того, она позволяет добавлять поддержку новых FS в ядро.

Linux поддерживает порядка 50 файловых систем.

На картинке:
- `Block-based FS` - эти FS используют блочные устройства для хранения данных;
- `Network FS` - сетевые FS, т.е. с ними мы работаем, как с фалами, но все наши вызовы транслируются по сети на удалённые хранилища;
- `Pseudo FS` - это, например, /proc, которая FS не является, там данные не хранятся, там реализован интерфейс доступа к данным из ядра;
- `Special purpuse` - эти FS тоже не используют внешние носители, а хранят все данные в памяти;


### Объекты файловой системы

#### `man 2 stat, /stat \{`
Посмотрим на системный вызов `stat`, который мы видели на схеме. Он используется для получения данных о файле.
Информацию о нём можно посмотреть в man: `man 2 stat`.

> Помним, что: `sudo apt-get install manpages-dev` - установка полной версии `man`, включая 2-й раздел.


`man 2 stat`:
```sh
struct stat {
	dev_t     st_dev;         /* ID устройства, содержащего файл */
	ino_t     st_ino;         /* номер Inode */
	mode_t    st_mode;        /* биты доступа + тип файла */
	nlink_t   st_nlink;       /* число hard links (жестких ссылок) */
	uid_t     st_uid;         /* User ID – принадлежность пользователю */
	gid_t     st_gid;         /* Group ID – принадлежность группе */
	dev_t     st_rdev; /* Device ID – тип устройства, если файл является файлом специального назначения */
	off_t     st_size;        /* Размер в байтах */
	struct timespec st_atim;  /* Время последнего доступа */
	struct timespec st_mtim;  /* Время последнего изменения содержимого */
	struct timespec st_ctim;  /* Время последнего изменения метаданных */
```

Так же есть одноимённая утилита `stat`, которая использует этот вызов и выводит в консоль те же данные, но в читаемом виде.\
Эта утилита входит в пакет [GNU Core Utilities](https://ru.wikipedia.org/wiki/GNU_Coreutils) и установлена в ОС по умолчанию.\
Пример:
```sh
vagrant@vagrant:~$ stat /etc/hosts
  File: /etc/hosts
  Size: 222             Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 262844      Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2022-03-16 14:13:47.340703817 +0000
Modify: 2021-12-19 19:39:18.555684984 +0000
Change: 2021-12-19 19:39:18.555684984 +0000
 Birth: -
```
Где:
- Size: 222 - размер файла в байтах;
- Blocks: 8 - количество блоков, которые занимает файл на HDD. 1 блок = 512 байт;
- IO Block: 4096 - размер блока файловой системы в кб. Задаётся при создании файловой системы;
- regular file - тип файла (в данном случай он обычный);
- Inode: 262844 - индексный дескриптор для этого файла, но об этом позже;
- Links: 1 - количество hard линков.
- (0644/-rw-r--r--) - права доступа;
- Uid:(0/root) - владелец файла;
- Gid:(0/root) - группа владельца файла;
- Access: 2022-03-16 14:13:47.340703817 +0000 - время доступа к файлу;
- Modify: 2021-12-19 19:39:18.555684984 +0000 - время изменения данных файла;
- Change: 2021-12-19 19:39:18.555684984 +0000 - время изменения метаданных файла;
- Birth: - время создания файла;

Даже при малом размере файла в 222 байта на устройстве выделено 8 блоков по 512 байт (так как минимальный блок ФС – 4096 байт)

#### `Inodе` или `index node` - индексный дескриптор файла.

inode - это область данных в файловой системе. Она хранит различные метаданные файла и указали на участки диска,
где хранятся сами данные, находящиеся внутри файла.

Индексый дескриптор имеет номер и в нашем примере `Inode = 262844`. Они хранятся отдельно в файловой системе в таблице
индексных дескрипторов и каждый имеет уникальное значение в пределах этой файловой системы.
Там же хранятся и указатели, о которых упоминалось выше.

Что же такое hard link?

Имя файла не является основным идентификатором, которым оперирует ОС. Основным идентификаторм является номер индексного дескриптора и именно по этой причине он является уникальным.
>Получается, что в FS может существовать несколько файлов, которые ссылаются на один и тот же номер индексного дескриптора!

Пример:

```sh
vagrant@vagrant:~/tmp$ touch file1.txt
vagrant@vagrant:~/tmp$ echo "Hello worldZ!" > file1.txt
vagrant@vagrant:~/tmp$ cat file1.txt
Hello worldZ!
vagrant@vagrant:~/tmp$ ln file1.txt file2.txt
vagrant@vagrant:~/tmp$ ls -alh
total 16K
drwxrwxr-x 2 vagrant vagrant 4.0K Mar 19 20:34 .
drwxr-xr-x 5 vagrant vagrant 4.0K Mar 19 19:55 ..
-rw-rw-r-- 2 vagrant vagrant   14 Mar 19 19:56 file1.txt
-rw-rw-r-- 2 vagrant vagrant   14 Mar 19 19:56 file2.txt
vagrant@vagrant:~/tmp$ stat file1.txt
  File: file1.txt
  Size: 14              Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 1048600     Links: 2
Access: (0664/-rw-rw-r--)  Uid: ( 1000/ vagrant)   Gid: ( 1000/ vagrant)
Access: 2022-03-19 19:56:28.726622427 +0000
Modify: 2022-03-19 19:56:22.967744427 +0000
Change: 2022-03-19 20:34:37.574474391 +0000
 Birth: -
vagrant@vagrant:~/tmp$ stat file2.txt
  File: file2.txt
  Size: 14              Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 1048600     Links: 2
Access: (0664/-rw-rw-r--)  Uid: ( 1000/ vagrant)   Gid: ( 1000/ vagrant)
Access: 2022-03-19 19:56:28.726622427 +0000
Modify: 2022-03-19 19:56:22.967744427 +0000
Change: 2022-03-19 20:34:37.574474391 +0000
 Birth: - 
```

В приведённом выше примере можно увидеть, что вроде как разные файлы на самом деле ссылаются на один и тот же
индексный дескриптор, а значит на одну и ту же область, в которой хранится содержимое файла.

>Как посмотреть все hard-линки на файл? Для этого надо вести поиск по значению `inode`

Пример:
```sh
vagrant@vagrant:~/tmp$ find -inum 1048600
./file1.txt
./file2.txt
```
С точки зрения ОС эти 2 файла являются равнозначными.



Команда `find <путь> -type f -printf '%n %p\n'` ищет и выводит список файлов указывая количество hard-линков и их имена. 




