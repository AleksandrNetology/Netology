## Операционные системы. Лекция 2.

#### Оценка потребления ресурсов

Хорошая статья на тему оценки производительности __[здесь](https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55).__

Краткая выдержка из неё по командам:

`uptime` — текущий аптайм, `Load Average` за 1, 5 и 15 минут соответственно;

`dmesg` — логи ядра, здесь могут быть ошибки, которые говорят о проблемах производительности (`oomkiller`, деградация дисковой подсистемы, сети и др.)\
Лучше использовать с ключом `-Т` для адекватного отображения времени: `dmesg -T`. Сравнительные примеры ниже.

	vagrant@vagrant:~$ dmesg
	[   46.052590] 13:14:10.463798 main     Executable: /opt/VBoxGuestAdditions-6.1.30/sbin/VBoxService
               13:14:10.463799 main     Process ID: 831
               13:14:10.463799 main     Package type: LINUX_64BITS_GENERIC
	[   46.058178] 13:14:10.469384 main     6.1.30 r148432 started. Verbose level = 0
	[   46.068606] 13:14:10.479786 main     vbglR3GuestCtrlDetectPeekGetCancelSupport: Supported (#1)

Тоже самое но в адекватном виде:

	vagrant@vagrant:~$ dmesg -T
	[Tue Feb 15 13:14:10 2022] 13:14:10.463798 main     Executable: /opt/VBoxGuestAdditions-6.1.30/sbin/VBoxService
                           13:14:10.463799 main     Process ID: 831
                           13:14:10.463799 main     Package type: LINUX_64BITS_GENERIC
	[Tue Feb 15 13:14:10 2022] 13:14:10.469384 main     6.1.30 r148432 started. Verbose level = 0
	[Tue Feb 15 13:14:10 2022] 13:14:10.479786 main     vbglR3GuestCtrlDetectPeekGetCancelSupport: Supported (#1)

----
Для дальнейшей работы нам потребуется большое количество разнообразных диагностических утилит.\
Все они содержатся в двух пакетах, которые необходимо будет установить, если их нет.\
Установка: `sudo apk-get install sysstat`\
Установка: `sudo apk-get install procps`

Утилита `vmstat`, пакет `procps`.

`vmstat <interval>` — общие метрики производительности в одном месте, выводятся на терминал раз в интервал времени <interval> в секундах:
- r, b — количество процессов в состоянии R и D соответственно;
- swpd, free, buff, cache — потребление памяти в системе: файл подкачки, свободной, выделенной под буферы и кеш;
- si, so - количество операций ввода/вывода swap;
- bi, bo — количество блоков прочитанных и записанных на диск;
- in, cs - количество прерываний и количество переключенией контекста - это когда планировщик ОС переключает другой процесс на это же ядро, отключив прежний процесс;
- us, sy, id, wa — процент времени, когда CPU был утилизирован под `userspace`; `kernelspace` задачи; когда он не выполнял никакой работы; когда задачи ожидали ввода/вывода.
```sh
	vagrant@vagrant:~$ vmstat 1
	procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
	r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
	1  0      0 1525840  42260 339852    0    0    66     6   19   79  0  0 100  0  0
	0  0      0 1525832  42260 339852    0    0     0     0   32   52  0  0 100  0  0
	0  0      0 1525832  42260 339852    0    0     0     0   31   53  0  0 100  0  0
	0  0      0 1525832  42260 339852    0    0     0     0   35   49  0  0 100  0  0
```
Причём первая строчка вывода - это среднее значение меток за всё время работы системы - не очень нужные данные.
Если выводить данные каждую секунду, то можно отловить какие-то пики в работе системы т.е. неравномерную нагрузку.

Тоже самое, но память в мегабайтах:

	vagrant@vagrant:~$ vmstat -S M 1
	procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
	r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
	1  0      0   1490     41    331    0    0    54     5   18   68  0  0 100  0  0
	0  0      0   1490     41    331    0    0     0     0   26   36  0  0 100  0  0
	0  0      0   1490     41    331    0    0     0     0   27   41  0  0 100  0  0

----

Утилита `mpstat` ставится с пакетом `sysstat`.

`mpstat` — утилизация процессора в разрезе ядер, с помощью которой можно увидеть дисбаланс распределения нагрузки по ядрам;

В примере ниже, мы просим выводить загрузку по всем CPU каждые 2 секунды:

	vagrant@vagrant:~$ mpstat -P ALL 2
	Linux 5.4.0-91-generic (vagrant)        02/16/2022      _x86_64_        (2 CPU)
	
	02:53:34 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
	02:53:36 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
	02:53:36 PM    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
	02:53:36 PM    1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00

----
Утилита `pidstat` также содержится в пакете `sysstat`.

`pidstat` — раз в интервал выводит полезные метрики утилизации ресурсов по процессам (CPU, RAM, IO);

Основные ключи утилиты:
- -t показывает треды;
- -d показывает метрики ввода/вывода;
- -r утилизация памяти;
- -u утилизация процессора.

Пример работы:

	vagrant@vagrant:~$ pidstat
	Linux 5.4.0-91-generic (vagrant)        02/16/2022      _x86_64_        (2 CPU)

	02:57:27 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
	02:57:27 PM     0         1    0.00    0.01    0.00    0.01    0.01     1  systemd
	02:57:27 PM     0         2    0.00    0.00    0.00    0.00    0.00     1  kthreadd
	02:57:27 PM     0         9    0.00    0.00    0.00    0.00    0.00     0  ksoftirqd/0
	02:57:27 PM     0        10    0.00    0.01    0.00    0.01    0.01     1  rcu_sched
	02:57:27 PM     0       523    0.03    0.03    0.00    0.00    0.05     0  multipathd

%usr - утилизация CPU в `userspace`;\
%system - утилизация CPU в `kernelspace`. Здесь значение больше, если процесс занят вводом\выводом, т.е. чаще работаю системные вызовы;

Как обычно, больше информации в `man` или __[посмотреть тут](https://bloglinux.ru/1972-utilita-pidstat-v-unix-linux.html).__

----
Утилита `iostat`, находится в пакете `sysstat`.

`iostat` — метрики подсистемы ввода вывода дисковых устройств:
- r/s, w/s количество запросов чтения и записи к устройству;
- rkB/s, wkB/s количество байт считанных или записанных;
- avgrq-sz, avgqu-sz средний размер запроса в байтах и среднее количество запросов в очереди на обслуживание;
- r_await, w_await среднее время обслуживание запроса в миллисекундах, включая ожидание в очереди.

----

`free` — использование памяти в системе, пакет `procps`.

	vagrant@vagrant:~$ free -m
			total        used        free      shared  buff/cache   available
	Mem:           2992         136        2446           0         409        2697
	Swap:          1961           0        1961

- total - количество памяти в истеме;
- user - количество памяти занятое программами;
- free - свободное количество памяти;
- shared - ;
- buff/cache - память ядра, выделенная под буфер устройств ввода/вывода и page-кэш, в котором хранятся уже прочитанные файлы;
- available - всего доступной памяти.

Ядро старается максимально оптимизировать расход памяти, поэтому всю память из free она отправляет на хренение 
буфера и кэша, но если вдруг память потребуется какому-то процессу - то она берётся именно из раздела buff/cache.

__total = used + free + buff/cache__\
Помня, что раздел buff/cache может быть _почти_ полностью освобождён, можно считать, что свободной памяти у нас __free + buff/cache__.

available - это free + buff/cache минус то, что невозможно освободить в разделе free + buff/cache.

----

Ещё одна популярная утилита для мониторинга производительности системы - __sar__.

Эта утилита не входит в стандартную поставку, она содержится в пакете `sysstat`.\
Помимо её установки, требуется настройка, а именно редактирование файлов конфигурации:\
`sudo nano /etc/default/sysstat` - в этом файле меняем строку с `ENABLED=”false”` на `ENABLED=”true”`, сохраняем.\
Теперь изменим интервал сбора информации с каждых 10 минут и меняем на каждые 2 минуты:\
`sudo vim /etc/cron.d/sysstat`:

	#Меняем строчку с
	5-55/10 \* \* \* \* root command -v debian-sa1 > /dev/null && debian-sa1 1 1
	#На
	\*/2 \* \* \* \* root command -v debian-sa1 > /dev/null && debian-sa1 1 1

И перезапускаем сервис `sysstat`: `sudo service sysstat restart`

`sar` приступает к сбору информации о работе системы.

`sar` — может показывать раличные метрики производительности:
- -n DEV, -n EDEV - утилизация сетевых интерфейсов и дропы пакетов на них - колонки `rxdrop` и `txdrop`. Это канальный уровень, фреймы ethernet;
- -n IP 1 - статистика IP-пакетов: irec, fwddgm - количество принятых и маршрутизированных пакетов;
- -n TCP, -n ETCP, -n UDP метрики TCP и UDP протоколов (кол-во соединений в секунды, ретрансмиты и др.);
- -B метрики использования page cache;
- -b, -d метрики IO по устройствам;
- -F метрики от смонтированных файловых систем;

Потери (дропы) происходят из-за того, что сетевой интерфейс слишком сильно загружен (утилизирован) и поступающие на него очередные пакеты
переполняют буфер, в результате чего ядро ОС вынуждено отбрасывать "лишние" пакеты.



#### Ядро и модули

#### Система инициализации: systemd



#### Примечания.
Описание утилиты `sar` [в этой статье](https://linux-notes.org/sar-dlya-monitoringa-proizvoditel-nosti-sistemy/)