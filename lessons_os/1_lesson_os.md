# Операционные системы. Лекция 1.

Конфигурация операционной системы - это набор txt-файлов.
А значит и вся конфигурация ОС сводится к редактирования txt-файлов.
	
Философия (?) unix: ОС - это набор небольших компонентов, каждый из которых
выполняет только одну задачу, но делает это идеально.
Комбинирование этих компонентов позволят решать сложные задачи.
Например, при работе в терминале использование технологии pipe.
	
	POSIX - Portable Operatin System Interface for uniX
POSIX - стандарт совмести всяких unix'ов для возможности запуска одних
и тех же программ и скриптов под разными версиями unix.
	
Например, в нём описаны переменные окружения, синтаксис shell и его возможности,
утилиты, которые должны быть (Coreutils) - это то, что интересно системным администраторам.
	
Системные вызовы - это методы общения приложений и ОС, а точнее с ядром ОС.
	
Напрямую системные вызовы используются редко. Для упрощения обращений
приложений к ядру предназначены библиотеки. В линуксе подобной библиотекой
является glibc - GNU Lib C.
	
	ldd - утилита, показывающая, с какими библиотеками __динамически__ линкуется приложение
Пример:

	vagrant@netology:~$ ldd /usr/bin/bash
	linux-vdso.so.1 (0x00007ffd74786000)
	libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007fdccdf74000)
	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fdccdf6e000)
 	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fdccdd7c000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fdcce0d9000)


В линуксе есть утилиты, т.н. трассировщики, которые позволяют посмотреть,
какие системные вызовы использует программа.
	
`strace` - программа, использующая подсистему ядра ptrace для отслеживания системных вызовов.
	
`ltrace` - программа для отслеживания библиотечных вызовов.
	
	
Пример, где `strace` показывает системный вызов `fstat` команды `ls`:

		vagrant@netology:~$ strace -e fstat ls
		fstat(3, {st_mode=S_IFREG|0644, st_size=25795, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0644, st_size=163200, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0755, st_size=2029224, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0644, st_size=584392, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0644, st_size=18816, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0755, st_size=157224, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0644, st_size=3035952, ...}) = 0
		fstat(3, {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
		fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
		test
		+++ exited with 0 +++

Информация по системным вызовам будет доступна в `man 2` после установки пакета manpages-dev:

	vagrant@netology:~$ sudo apt-get install manpages-dev

* `man 2` - это 2й раздел man, где описаны все системные вызовы. Например, `man 2 fstat` или `man 2 write`
	
Ещё один пример использования `strace`:

	vagrant@netology:~$ cat ttt.py
	import sys
	with open(sys.argv[1]) as f:
			frint(f.read())
	vagrant@netology:~$ echo -n "Hello, Netology!" > file
	vagrant@netology:~$ strace -e openat,write,read,close python3
	ttt.py file > /dev/null
	
	<...>
	openat(AT_FDCWD, "file", 0_RDONLY|)_CLOEXEC) = 3
	read(3, "Hello, Netology!", 17) = 16
	read(3, "", 1) = 0		
	close(3) = 0		
	write(1, "Hello, Netology!\n", 17) = 17
	+++ exited with 0 +++
	---
`openat` открыл file и вернул номер файлового дескриптора - {3}, `read` прочитал 16 байт,
`close` закрыл дескриптор {3}, `write` написал содержимое в `stdout`.
	
`strace` можно использовать для уже работающих программ для анализа их работы.
Для этого есть ключ `-p`.

Пример:

	vagrant@netology:~$ while true; do date +%s > /dev/null; done &
	[1] 1575

>Запускается фоновый процесс PID = 1575
>Фоновый, т.к. в конце блока команд стоит &.

	vagrant@netology:~$ strace -p 1575 -e write	# Просим strace показать все системные вызовы write нашего процесса
	write(1, "12345\n", 6)                  = 6
	write(1, "12345\n", 6)                  = 6
	write(1, "12345\n", 6)                  = 6	# 6 - это 6 байт, циферки 1--5 и "\n"
	^Cstrace: Process 1575 detached			# Ctrl+С - остановил трассировку.
	
Кстати, лучше всего этот скрипт запустить через утилиту screen, а самому процессу понизить
приоритет с помощью команды renice -n 19 PID. Иначе оный процесс слишком сильно загружает
CPU и консоль сильно тормозит.

>[Про nice/renice можно почитать тут](https://losst.ru/upravlenie-protsessami-v-linux).
	
Важно, что `strace` может перехватывать системные вызовы дочерних процессов по отношению к перехваченному.
Для этого существует ключ `-f`:

	vagrant@netology:~$ strace sh -c date
		vs
	vagrant@netology:~$ strace -f sh -c date
	
Несколько полезных опций `strace`:
>По умолчанию вывод строк ограничен 32 байтами. Используя ключ `-s` можно увидеть больше.
Например, `-s 65000`, позволит увидеть всю строку целиком. Но в этом случае может понадобиться
вывод в файл вместо вывода на экран, а для этого нужно применить ключ `-o`.

>Ключ `-y` включает аннотации к файловым дескрипторам, т.е. имена файлов.

>Ключ `-e` фильтр, который позволяет найти только заданные системные вызовы:
	`strace -e write,open,input`
Как видно из примера, искомые системные вызовы перечислены через `,`.

Пример:

	vagrant@netology:~$ strace -e stat bash -c "date"

В этом примере мы ищем системный вызов `stat` в запущенном `bash`, который пытается найти и выполнить `date`

И, кстати, если выполнить `echo $PATH`, то можно увидеть, что поиск `date` происходит том порядке,
как пути перечислены в этой переменной. Как только командный интерпретатор находит искомое - поиск завершается.

## eBPF

__eBPF__ - ещё один инструмент для отслеживания событий в ОС. Это виртуальная машина в ядре ОС.\
Как установить: `sudo apt-get install bpfcc-tools`

Смотрим, из каких компонентов состоит: `dpkg -L grep bpfcc-tools | grep bin`

Как пользоваться всем этим - ищем в интернете и мануалах.

## Процессы и треды

Процесс - это поток выполнения программы + память + открытые файловые дескрипторы + переменные окружения
Тред - это поток выполнения инструкций. В процессе может быть несколько тредов: они выполняются одновременно
и параллельно. При этом они используют общую память т.к. выполняются внутри одного процесса,
они имею доступ к одним и тем же переменным и пр. Вот тут и возникает проблема взаимной синхронизации,
чтобы потоки не пытались изменить, например, одновременно одну и ту же переменную.

## fork/clone наследование

Рассматривая файловые дескрипторы, мы узнали, что они наследуются новым процессом от своего родителя.
Т.е. запущенный из bash скрипт будет отправлять данные на тот же стандартный выход, что был назначен
для bash и открыт им. При этом PID у него будет другой.

Процессы в линуксе создаются *системными* вызовами `fork` или `clone`.
В мануале сказано, например, что `fork` создаёт полностью дублируя тот, из которого он запущен.
Новый процесс становится дочерним по отношению к тому, из которого его вызвали. На момент создания
дочернего процесса он будет полностью идентичен родительскому: одинаковое содержимое памяти, открытые файловые
дескрипторы, переменные окружения, но у них будут различные PID.
```
    parent -----> fork() -----------> exec() --------------> exit()
			  parent	|	child	     |
					|	 	     | status
					|		     \/
					------------------> wait() -------->
						parent		    parent
							
```

После того, как родитель вызвал `fork`, в памяти находится 2 идентичных процесса в одной точке исполнения.
Разница между ними - код возврата системного вызова, по которому процесс понимает, является ли он 
родителем т.е. получает PID для потомка, или новым дочерним процессом т.е. получает системный код
возврата 0 из `fork`.

После вызова `fork` (или `clone`) родительский процесс должен сделать `wait` на PID нового процесса,
дожидаясь его завершения.
Если по какой-то причине родительский процесс не смог отработать или получить код возврата от дочернего
процесса, либо родительский процесс уже завершился, то такой дочерний процесс становится *зомби* и завершившись,
останется висеть в виде строки в таблице процессов ядра. При этом никакие ресурсы системы он не потребляет, что
можно видеть из таблицы:
```sh
vagrant@vagrant:~$ ps aux | grep defunct
vagrant     1170  0.0  0.0      0     0 pts/1    Z+   17:25   0:00 [reptyr] <defunct>
```

>Зомби-процессы, это такие дочерние процессы, которые не могут вернуть родительскому процессу ответ
>потому что этот ответ никто не ждёт.

Получается, что процесс не живой т.к. он выполнил свою работу, но и не мёртвый т.к. не может закрыться
не вернув код возврата родительскому процессу.

Зомби-процесс *убить* невозможно, но если завершить его родительский процесс, то код возврата зомби перехватит
системный процесс PID(1) и тем самым позволит ему спокойно почить...

Пример:
```sh
vagrant@vagrant:~$ ps aux | grep defunct 						#---Ищем зомби-процесс
vagrant     1170  0.0  0.0      0     0 pts/1    Z+   17:25   0:00 [reptyr] <defunct>	#---Вот он, обозначен Z+, PID=1170
vagrant     1261  0.0  0.0   6432   672 pts/0    S+   17:31   0:00 grep --color=auto defunct
vagrant@vagrant:~$ ps -xal | grep defunct						#---Ищем родителя нашего зомби.
											#---Это процесс 1169
1  1000    1170    1169  20   0      0     0 -      Z+   pts/1      0:00 [reptyr] <defunct>
0  1000    1263    1217  20   0   6432   740 pipe_w S+   pts/0      0:00 grep --color=auto defunct
vagrant@vagrant:~$ kill 1169								#---Убиваем родительский процесс
vagrant@vagrant:~$ ps aux | grep defunct						#---Проверяем, что зомби-процесс пропал.
vagrant     1265  0.0  0.0   6432   672 pts/0    S+   17:32   0:00 grep --color=auto defunct
```

>В целом оно так и задумано: если мы убиваем некий процесс, то всего дочерние передаются на управление системному PID(1).

 Теперь вернёмся к __exec()__.
 
`exec()` - это семейство команд, которые позволяют заменить в памяти текущий процесс на другой, указанный у них в аргументе.

При вызове `fork` физического копирования данных в памяти не происходит. Благодаря механизму виртуальной памяти ядро просто
назначает одни и те же участки разным процессам, а механизм copy-on-write уже записыват при необходимости только измняющиеся
данные для нового процесса.

## Код возврата

Штатным способом завершения процесса служит системный вызов `exit (exit_group)`. Абсолютно каждый процесс отправляет
свой код возврата родительскому процессу! Получив его, ОС понимает, что нужно освободить ресурсы, которые использовал процесс.
Возвращаемый __exit code__ - важный признак, по которому можно сделать вывод об успешности завершённого процесса.

>Код возврата 0 сигнализирует об успешности завершения процесса.
>Отличные от нуля значения говорят об том, что процесс завершился с ошибкой. Какое именно значение в случае ошибки вернёт
>процесс - зависит от его настроек.

В bash узнать код возврата можно через служебную переменную `?`: `echo $?`

Важно знать, что код возврата собирает со всех своих дочерних процессов wait.

Особенно полезен код возврата (`exit code`) в сценариях для обработки ошибок.


## Про среднюю загрузку

`uptime` - команда, показывающая среднюю загрузку (LA) системы за последние 1, 5, 15 минут.

`Load Average`(LA) - среднее число процессов в состояниях __R__ и __D__ за рассчитываемый промежуток времени.
>Помним, что LA это НЕ нагрузка на CPU!\
>__LA - это нагрузка на CPU + нагрузка IO на дисковую подсистему!__

Подробнее про `uptime` и `LA` будет в следующей лекции.

## Просмотр таблицы процессов

Команда `ps` - process state. По умолчанию показывает `собственные` процессы пользователя в том терминале, из которого запущена.

`ps aux` - наиболее часто используемая комбинация.\
-ключ `a` - убирает ограничение о `собственных` процессах;\
-ключ `u` - добавляет расширенный набор колонок;\
-ключ `x` - убирает ограничение о процессах, запущенных их текущего терминала;\
-ключ `w/ww` - убирает ограничение по длине вывода.\

> Посмотреть процессы конкретного пользователя: `ps -u <user> u`.
>> Обратить внимание, что `-u` и `u` - это разные ключи. Минус имеет значение!\

> Расширенный вывод с дополнительными колонками: `ps -p <PID> -o pid,user,comm,etime,%mem,%cpu`\
> С добавлением сортировки: `ps -o pid,user,comm,etime,%mem,%cpu --sort=-%mem`

## Состояния процессов

Это основные состояния.

__D__ - uninterruptible sleep - непрерываемый сон, обычно во время операция ввода\вывода. Защита данных от потери;\
__R__ - running\runnable - исполняется или ожидает исполнения;\
__S__ - interruptible sleep - обычный спящий процесс, который *может быть прерван*, он оживает какого-то события;\
__T__ - остановлен сигналом управления задачами;\
__Z__ - зомби-процесс.

С описание всех состояний можно ознакомиться воспользовавшись `man ps`.

Значения дополнительных символов и букв:\
```
<    - процесс с высоким приоритетом;
N    - процесс с низким приоритетом;
L    - у процесса есть залоченные в памяти страницы (для ввода-вывода в реальном времени и пользовательского ввода-вывода)
s    - [лидер сессии](https://qastack.ru/unix/18166/what-are-session-leaders-in-ps)
l    - мультипоточный процесс
+    - находится в группе процессов переднего плана
```


## Управление процессами. Сигналы.

Одна из форм взаимодействия процессов - сигналы.

Процессу можно послать спец. код, который он может обработать.\
-Ctrl+Z и Ctrl+С отправляют сигналы `TSTP` (temporary stop) и `INT` (interrupt) соответственно.

Команда `kill` - ещё один способ отправить сигнал процессу.
Несмотря на своё название, `kill` может послать любой сигнал процессу, но по умолчанию, применяет сигнал `TERM` (terminate).
Например, `kill -HUP $(cat /var/run/ngnix.pid)` просит процесс перечитать свои конфигурационные файлы без перезапуска.

Сигналы могут быть поданы по имени или по номеру.
Например, знаменитый `kill dash nine (-9)` - принудительное завершение на случай невозможности выхода программы по штатному сигналу -15.

`SIGKILL` (kill -9) и `SIGSTOP` - это пара сигналов, которые не могут быть перехвачены процессом и обработаны каким-либо образом по желанию
разработчика. На все остальные сигналы можно повесить обработчики.

>Обращаем внимание, что нельзя "убить" процесс в состоянии __D__ и __Z__.

## Треды исполнения. 
*Треды - потоки, нити*

Тред - это поток выполнения. 
Многопоточность - это как раз про параллельное выполнение нескольких потоков, тредов.
Треды имеют общую память, а потому их удобно использоваться для распараллеливания - они могут обмениваться данными через общую память.

Почему не *процессы* используют для распараллеливания?
Потому что это гораздо сложнее - у них разные области памяти и обмениваться данными они могут только через специальные системные вызовы ядра.

`ps sux -T` покажет процессы и их треды. У тредов будет один и тот же PID, т.к. они принадлежат одному процессу, а вот идентификаторы тредов,
аналог PID, будут различны.

## Атрибуты процессов

- PID, PIDD;
- файловые дескрипторы;
- переменные окружения (также наследуются от родителя);
- обработчик сигналов (системный по умолчанию или собственный);
- область данных в памяти (`stack`, `heap`, `data`, `text` - в данной лекции не рассматривались);
- один или более тредов.

## Дополнительные атрибуты  процессов

- принадлежность пользователю и группе;
- параметры запуска процесса: `cat  /proc/PID/cmdline`
- принадлежность пространству имён;
- capabilities - расширение концепции (не)привилигированных процессов: `getcap $(which ping)`
