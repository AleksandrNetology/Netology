# Операционные системы. Лекция 1.

Конфигурация операционной системы - это набор txt-файлов.
А значит и вся конфигурация ОС сводится к редактирования txt-файлов.
	
Философия (?) unix: ОС - это набор небольших компонентов, каждый из которых
выполняет только одну задачу, но делает это идеально.
Комбинирование этих компонентов позволят решать сложные задачи.
Например, при работе в терминале использование технологии pipe.
	
	POSIX - Portable Operatin System Interface for uniX
POSIX - стандарт совмести всяких unix'ов для возможности запуска одних
и тех же программ и скриптов под разными версиями unix.
	
Например, в нём описаны переменные окружения, синтаксис shell и его возможности,
утилиты, которые должны быть (Coreutils) - это то, что интересно системным администраторам.
	
Системные вызовы - это методы общения приложений и ОС, а точнее с ядром ОС.
	
Напрямую системные вызовы используюся редко. Для упрощения обращений
приложений к ядру предназначены библиотеки. В линуксе подобной библиотекой
является glibc - GNU Lib C.
	
	ldd - утилита, показывающая, с какими библиотеками __динамически__ линкуется приложение
Пример:

	vagrant@netology:~$ ldd /usr/bin/bash
	linux-vdso.so.1 (0x00007ffd74786000)
	libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007fdccdf74000)
	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fdccdf6e000)
 	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fdccdd7c000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fdcce0d9000)


В линуксе есть утилиты, т.н. трассировщики, которые позволяют посмотреть,
какие системные вызовы использует программа.
	
`strace` - программа, использующая подсистему ядра ptrace для остлеживания системных вызовов.
	
`ltrace` - программа для остлеживания библиотечных вызовов.
	
	
Пример, где `strace` показывает системный вызов `fstat` команды `ls`:

		vagrant@netology:~$ strace -e fstat ls
		fstat(3, {st_mode=S_IFREG|0644, st_size=25795, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0644, st_size=163200, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0755, st_size=2029224, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0644, st_size=584392, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0644, st_size=18816, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0755, st_size=157224, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
		fstat(3, {st_mode=S_IFREG|0644, st_size=3035952, ...}) = 0
		fstat(3, {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
		fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
		test
		+++ exited with 0 +++

Информация по системным вызовам будет доступна в `man 2` после установки пакета manpages-dev:

	vagrant@netology:~$ sudo apt-get install manpages-dev

* `man 2` - это 2й раздел man, где описаны все системные вызовы. Например, `man 2 fstat` или `man 2 write`
	
Ещё один пример использования `strace`:

	vagrant@netology:~$ cat ttt.py
	import sys
	with open(sys.argv[1]) as f:
			frint(f.read())
	vagrant@netology:~$ echo -n "Hello, Netology!" > file
	vagrant@netology:~$ strace -e openat,write,read,close python3
	ttt.py file > /dev/null
	
	<...>
	openat(AT_FDCWD, "file", 0_RDONLY|)_CLOEXEC) = 3
	read(3, "Hello, Netology!", 17) = 16
	read(3, "", 1) = 0		
	close(3) = 0		
	write(1, "Hello, Netology!\n", 17) = 17
	+++ exited with 0 +++
	---
`openat` открыл file и вернул номер файлового дескриптора - {3}, `read` прочитал 16 байт,
`close` закрыл дескриптор {3}, `write` написал содержимое в `stdout`.
	
`strace` можно использовать для уже работающих программ для анализа их работы.
Для этого есть ключ `-p`.

Пример:

	vagrant@netology:~$ while true; do date +%s > /dev/null; done &
	[1] 1575

>Запускается фоновый процесс PID = 1575
>Фоновый, т.к. в конце блока команд стоит &.

	vagrant@netology:~$ strace -p 1575 -e write	# Просим strace показать все системные
												# вызовы write нашего процесса
	
	write(1, "12345\n", 6)                  = 6
	write(1, "12345\n", 6)                  = 6
	write(1, "12345\n", 6)                  = 6	# 6 - это 6 байт, циферки 1--5 и "\n"
	^Cstrace: Process 1575 detached			# Ctrl+С - остановил трассировку.
	
Кстати, лучше всего этот скрипт запустить через утилиту screen, а самому процессу понизить
приоритет с помощью команды renice -n 19 PID. Иначе оный процесс слишком сильно загружает
CPU и консоль сильно тормозит.

Как-то надо добавить ещё и команду `sleep`, чтоб процесс замирал на какое-то время, немного разгружая систему.

>Про nice/renice можно почитать [тут](https://losst.ru/upravlenie-protsessami-v-linux).
	
Важно, что `strace` может перехватывать системные вызовы дочерних процессов по отношению к перехваченному.
Для этого существует ключ `-f`:

	vagrant@netology:~$ strace sh -c date
		vs
	vagrant@netology:~$ strace -f sh -c date
	
Несколько полезных опций `strace`:
>По умолчанию вывод строк ограничен 32 байтами. Используя ключ `-s` можно увидеть больше.
Например, `-s 65000`, позволит увидеть всю строку целиком. Но в этом случае может понадобиться
вывод в файл вместо вывода на экран, а для этого нужно применить ключ `-o`.

>Ключ `-y` включает аннотации к файловым дескрипторам, т.е. имена файлов.

>Ключ `-e` фильтр, который позволяет найти только заданные системные вызовы:
	`strace -e write,open,input`
Как видно из примера, искомые системные вызовы перечислены через `,`.

Пример:
	vagrant@netology:~$ strace -e stat bash -c "date"
В этом примере мы ищем системный вызов `stat` в запущенном `bash`, который пытается найти и выполнить `date`

И, кстати, если выполнить echo $PATH, то можно увидеть, что поиск `date` происходит том порядке,
как пути перечисленны в этой переменной. Как только командный интерпритатор находит искомое - поиск завершется.

__eBPF__ - ещё один инструмент для отслеживания событий в ОС. Это виртуальная машина в ядре ОС.\
Как установить: `sudo apt-get install bpfcc-tools`

Смотрим, из каких компонентов состоит: `dpkg -L grep bpfcc-tools | grep bin`

Как пользоваться всем этим - ищем в интренете и манулах.

__Процессы и треды.__\
Процесс - это поток выполнения программы+память + открытые файловые дескрипторы + переменные окружения
Тред - это поток выполнения инструкций. В процессе может быть несколько тредов: они выполняются одновременно
и параллельно. При этом они используют общую память т.к. выполняются внутри одного процесса,
они имею доступ к одним и тем же переменным и пр. Вот тут и возникает проблема взаимной синхронизации,
чтобы потоки не пытались изменить, например, одновременно одну и ту же переменную.

__fork/clone наследование__\
Рассматривая файловые дескрипторы, мы узнали, что они наследуются новым процессом от своего родителя.
Т.е. запущенный из bash скрипт будет отправлять данные на тот же стандартный выход, что был назначен
для bash и открыт им. При этом PID у него будет другой.

Процессы в линуксе создаются *системными* вызовами `fork` или `clone`.
В мануале сказано, например, что `fork` создаёт полностью дублируя тот, из которого он запущен.
Новый процесс становится дочерним по отношению к тому, из которого его вызвали. На момент создания
дочернего процесса он будет полностью идентичен родительскому: одинаковое содержимое памяти, открытые файловые
дескрипторы, переменные окружения, но у них будут различные PID.
```
    parent -----> fork() -----------> exec() --------------> exit()
			  parent	|	child	     |
					|	 	     | status
					|		     \/
					| ----------------> wait() ----->
						parent		   parent
							
```

 После того, как родитель вызвал `fork`, в памяти находится 2 идентичных процесса в одной точке исполнения.
Разница между ними - код возврата системного вызова, по которомы процесс понимает, является ли он 
родителем т.е. получает PID для потомка, или новым дочерним процессом т.е. получает системный код
возврата 0 из `fork`.

 После вызова `fork` (или `clone`) родительский процесс должен сделать `wait` на PID нового процесса,
дожидаясь его завершения.
 Если по какой-то причине родительский процесс не смог отработать или получить код возврата от дочернего
процесса, либо родительский процесс уже завершился, то такой дочерний процесс становится *зомби* и завершившись,
останется висеть в виде строки в таблице процессов ядра.

>Зомби-процессы, это такие дочерние процессы, которые не могут вернуть родительскому процессу ответ
>потому что этот ответ никто не ждёт.

Получается, что процесс не живой т.к. он выполнил свою работу, но и не мёртвый т.к. не может закрыться
не вернув код созврата родительскому процессу.

Зомби-процесс *убить* невозможно, но если завершить его родительский процесс, то код возврата зомби перехватит
системный процесс PID(1) и тем самым позволит ему спокойно почить...

Пример:
```sh
vagrant@vagrant:~$ ps aux | grep defunct 						#---Ищем зомби-процесс
vagrant     1170  0.0  0.0      0     0 pts/1    Z+   17:25   0:00 [reptyr] <defunct>	#---Вот он, обозначен Z+, PID=1170
vagrant     1261  0.0  0.0   6432   672 pts/0    S+   17:31   0:00 grep --color=auto defunct
vagrant@vagrant:~$ ps -xal | grep defunct						#---Ищем родителя нашего зомби.
											#---Это процесс 1169
1  1000    1170    1169  20   0      0     0 -      Z+   pts/1      0:00 [reptyr] <defunct>
0  1000    1263    1217  20   0   6432   740 pipe_w S+   pts/0      0:00 grep --color=auto defunct
vagrant@vagrant:~$ kill 1169								#---Убиваем родительский процесс
vagrant@vagrant:~$ ps aux | grep defunct						#---Проверяем, что зомби-процесс пропал.
vagrant     1265  0.0  0.0   6432   672 pts/0    S+   17:32   0:00 grep --color=auto defunct
```

>В целом оно так и задумано: если мы убиваем некий процесс, то всего дочерние передаются на управление системному PID(1).

 Теперь вернёмся к __exec()__.
 
 `exec()` - это семейство команд, которые позволяют заменить в памяти .....

