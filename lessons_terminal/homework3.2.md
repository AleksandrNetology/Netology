# Домашнее задание 3.2. Работа в терминале, лекция 2

>1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа;
	опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

__Выполнение__
	
```sh
	vagrant@netology:~$ type -t cd
	builtin 
```

Почему она такого типа?
```
Потому что возможность перемещаться по директориям - неотъемлемое свойство ОС.
Наверное, её можно изъять из ОС и сделать внешней устанавливаемой утилитой, но
в этом случае её придётся инталлировать первой, сразу после установки ОС.
Далее прописывать к ней пути, права доступа, делать доступной всем пользователям...
Это, конечно, очень про юниксовому, но тут здравый смысл сумел победить.
Зачем всё это городить? Проще встроить в оболочку.
```
--------------------------------------------------------------------------------------
	
>2. Какая альтернатива без `pipe` команде `grep <some_string> <some_file> | wc -l`?\
	man grep поможет в ответе на этот вопрос.\
	__[Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe](http://www.smallo.ruhr.de/award.html)__

__Выполнение__

То же самое без использования pipe:	`vagrant@netology:~$: grep -c if .bashrc`

--------------------------------------------------------------------------------------


>3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

__Выполнение__
```sh
	vagrant@netology:~$ pstree -p
	systemd(1)─┬─VBoxService(873)─┬─{VBoxService}(874)
```	

Т.о. systemd(1) является родителем для всех процессов.

--------------------------------------------------------------------------------------

>4. Как будет выглядеть команда, которая перенаправит вывод `stderr` команды `ls` на другую сессию терминала?


__Выполнение__
	
Сделал непосредственно в терминале ВМ.

	Если мы в /dev/tty1 , то подойдёт что-то типа:
	ls Hello! 2>/dev/ttyX , где X - номер другой существующей сессии.
				Именно в ней и появится сообщение об ошибке:
				ls: cannot access 'Hello!': No such file or directory
	
Пример через удалённый терминал:

![](https://github.com/AleksandrNetology/Netology/blob/main/lessons_terminal/term_to_term.JPG)

--------------------------------------------------------------------------------------

>5. Получится ли одновременно передать команде файл на `stdin` и вывести ее `stdout` в другой файл?
	Приведите работающий пример.

__Выполнение__
```sh
	vagrant@netology:~$ cat tmp/f1.txt 			# Смотрим содержимое исходного файла
	1 - uno
	2 - due
	3 - tre
	4 - quattro
	5 - cinque
	vagrant@netology:~$ cat tmp/summ.txt 			# Смотрим содержимое результирующего файла
	undici - 11
  netology:~$ cat test/summ.txt 			# Проверяем содержимое результирующего файла
	vagrant@netology:~$ cat <tmp/f1.txt >>tmp/summ.txt	# Выполнение поставленной задачи
	vagrant@netology:~$ cat tmp/summ.txt 			# Проверяем содержимое результирующего файла
	undici - 11
	1 - uno
	2 - due
	3 - tre
	4 - quattro
	5 - cinque
	vagrant@netology:~$
```
--------------------------------------------------------------------------------------

>6. Получится ли находясь в графическом режиме, вывести данные из `PTY` в какой-либо из эмуляторов `TTY`?
	Сможете ли вы наблюдать выводимые данные?

__Выполнение__
	
Да, вывести данные из PTY в имеющийся TTY получится используя перенаправления:
```sh
	vagrant@netology:~$ tty
    	/dev/pts/0
	vagrant@netology:~$ echo Hello! >/dev/tty0
```	
Увидеть получится только если TTY открыт на экране.

--------------------------------------------------------------------------------------

>7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5?`\
	Почему так происходит?

__Выполнение__
```sh
	vagrant@netology:~$ echo $$		# Проверяем свой PID
	1589					# pid = 1589
	vagrant@netology:~$ bash 5>&1		# запускаем новую сессию bash, в которой создаём новый файловый  
						# дескриптор (fd) 5 и перенаправляем его вывод на стандартный вывод stdout
	vagrant@netology:~$ echo $$		# Проверяем свой PID
	1978					# pid = 1978
	vagrant@netology:~$ echo $PPID		# Проверяем, кто родитель текущей сессии. Просто так проверяем.
	1589					# pid = 1589
	vagrant@netology:~$ ll /proc/$$/fd	# Смотрим список существующих в этой сессии файловых дескрипторов (fd).
	total 0
	dr-x------ 2 vagrant vagrant  0 Feb  2 20:36 ./
	dr-xr-xr-x 9 vagrant vagrant  0 Feb  2 20:36 ../
	lrwx------ 1 vagrant vagrant 64 Feb  2 20:36 0 -> /dev/pts/0	# stdin
	lrwx------ 1 vagrant vagrant 64 Feb  2 20:36 1 -> /dev/pts/0	# stdout
	lrwx------ 1 vagrant vagrant 64 Feb  2 20:36 2 -> /dev/pts/0	# stderr
	lrwx------ 1 vagrant vagrant 64 Feb  2 20:36 255 -> /dev/pts/0
	lrwx------ 1 vagrant vagrant 64 Feb  2 20:36 5 -> /dev/pts/0	# Созданный нами в этой сессии fd
	vagrant@netology:~$ echo qwerty > /proc/$$/fd/5			# Выполняем команду
	qwerty				# Получаем закономерный результат: сообщение, отправленное в заранее созданный
	vagrant@netology:~$		# и настроенный fd появляется на стандартном выводе, т.е. в терминале.
```

В случае, если fd не был создан заранее, то мы, очевидно, получим сообщение об ошибке, как в примере ниже:
```sh
	vagrant@netology:~$ echo qwerty > /proc/$$/fd/6
	-bash: /proc/1589/fd/6: No such file or directory
```
--------------------------------------------------------------------------------------

>8. Получится ли в качестве входного потока для `pipe` использовать только `stderr` команды, не потеряв при этом отображение `stdout` на `pty`?
	Напоминаем: по умолчанию через `pipe` передается только `stdout` команды слева от `|` на `stdin` команды справа.
	Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

__Выполнение__
```sh
	vagrant@netology:~$ ll test
	total 24
	drwxrwxr-x 2 vagrant vagrant 4096 Feb  1 22:24 ./
	drwxr-xr-x 6 vagrant vagrant 4096 Feb  2 22:03 ../
	-rw-rw-r-- 1 vagrant vagrant    0 Feb  1 21:19 err.txt
	-rw-rw-r-- 1 vagrant vagrant   10 Feb  1 21:11 f1.txt
	-rw-rw-r-- 1 vagrant vagrant   16 Feb  1 21:12 f2.txt
	-rw-rw-r-- 1 vagrant vagrant   28 Feb  1 21:14 log.txt
	-rw-rw-r-- 1 vagrant vagrant   10 Feb  1 22:27 summ.txt
	vagrant@netology:~$ cat test/f3.txt 6>&2 2>&1 1>&6 | grep file
	cat: test/f3.txt: No such file or directory
	vagrant@netology:~$
```
`6>&2` - новый дескриптор {6} перенаправили в `stderr` {2}\
`2>&1` - `stderr` {2} перенаправили в `stdout` {1}\
`1>&6` - `stdout` {1} - перенаправили в в новый дескриптор {6}

---------------------------------------------------------------------------------------

>9. Что выведет команда cat `/proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?

__Выполнение__
	
Команда cat /proc/$$/environ выводит все переменные окружения скопом.\
Аналогичный по содержанию вывод делают следующие команды:
- printenv;
- env;
- export.

Однако, при работе этих команд переменные окружения выводятся построчно.

--------------------------------------------------------------------------------------

>10. Используя man, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

__Выполнение__
	
Запускаем `man proc`:
	
	в строке 226 находим описание:
	/proc/<PID>/cmdline:
	"Этот доступный только для чтения файл содержит полную командную строку для процесса, если этот процесс не является зомби..."
	
	в строке 279 находим описание:	
	"...этот файл представляет собой символическую ссылку, содержащую фактический путь к выполняемой команде..."

--------------------------------------------------------------------------------------

>11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

__Выполнение__

Результат можно получить двумя способами:
	
	1. vagrant@netology:~$ cat /proc/cpuinfo | grep sse
	
		или
		
	2. vagrant@netology:~$ grep sse /proc/cpuinfo
	...
	flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr
	sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni
	ssse3 cx16 pcid sse4_1 sse4_2 hypervisor lahf_lm pti fsgsbase md_clear flush_l1d arch_capabilities
	...

__Cтаршая версия набора инструкций SSE: sse4_2__

--------------------------------------------------------------------------------------

>12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется `pty`.
	Это можно подтвердить командой `tty`, которая упоминалась в [лекции 3.2](2.lesson_term.md).\
	Однако:

	vagrant@netology1:~$ ssh localhost tty
	not a tty

Почитайте, почему так происходит, и как изменить поведение.

__Выполнение__

Прочитал в статье: __[SSH inside SSH fails with "stdin: is not a tty"](https://unix.stackexchange.com/questions/48527/ssh-inside-ssh-fails-with-stdin-is-not-a-tty)__

Цитата:
	`"По умолчанию, когда вы запускаете команду на удаленном компьютере с помощью ssh,
	для удаленного сеанса не создаётся TTY..."`

Однако, если использовать ключ `-t`, то всё получится:
```sh
	vagrant@netology:~$ ssh -t localhost 'tty'
	vagrant@localhost's password:
	/dev/pts/1
	Connection to localhost closed.
	vagrant@netology:~$
```

--------------------------------------------------------------------------------------

>13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую.\
	Попробуйте сделать это, воспользовавшись reptyr. __[хелп по reptyr](https://github.com/nelhage/reptyr#readme)__\
	Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

__Выполнение__

Во-первых, надо исправить значение: kernel.yama.ptrace_scope = 0 в файле `/etc/sysctl.d/10-ptrace.conf`\
Во-вторых, можно использовать аналог `screen` - программой `tmux`.

```sh
sudo nano /etc/sysctl.d/10-ptrace.conf
kernel.yama.ptrace_scope = 0
```
Запускаю `tmux`, создаю пару сессий.\
В первой сессии: 
```sh
vagrant@vagrant:~$ htop &
[1] 1250
vagrant@vagrant:~$ jobs -l
[1]+  1250 Stopped (tty output)    htop
vagrant@vagrant:~$ disown 1250
-bash: warning: deleting stopped job 1 with process group 1250
vagrant@vagrant:~$ ps
    PID TTY          TIME CMD
   1192 pts/5    00:00:00 bash
   1250 pts/5    00:00:00 htop
   1251 pts/5    00:00:00 ps
vagrant@vagrant:~$
```
Захожу во вторую сессию:

```sh
vagrant@vagrant:~$ reptyr 1250
```
Запускается `htop`.

Однако!
Процесс ping(1160) перенести с помощью reptyr не получилось. См. ниже.
```sh
vagrant@vagrant:~$ pstree -p
...
         ├─tmux: server(1068)─┬─bash(1069)───bash(1159)───ping(1160)
         │                    ├─bash(1121)
         │                    ├─bash(1131)
         │                    ├─bash(1143)
         │                    ├─bash(1192)───htop(1250)───htop(1253)
         │                    ├─bash(1216)───reptyr(1252)
...
```

```sh
vagrant@vagrant:~$ echo $$
1121
vagrant@vagrant:~$ reptyr 1160
[-] Process 1159 (bash) shares 1160's process group. Unable to attach.
(This most commonly means that 1160 has suprocesses).
Unable to attach to pid 1160: Invalid argument
vagrant@vagrant:~$ reptyr -T 1160
[-] Unable to find the fd for the pty!
Unable to attach to pid 1160: No such process
vagrant@vagrant:~$ ps aux | grep ping
vagrant     1160  0.1  0.0   7092   932 pts/1    S    18:33   0:04 ping 8.8.8.8
```
Получается, что reptyr сработал с утилитой htop, но не сработал с циклами типа:

```sh
while true; do [что-нибудь] >> [файл]; sleep 1s; done &
```
Вывод:
```
Рептир - это костыль. Прежде чем запускать очень важную задачу - проверь, в той ли сессии планируешь запускать.
Это как зубы по утрам чистить или руки перед едой мыть. Если же всё-таки ошибся, то не тупи, перезапускай: помни, всё можно перезапустить, кроме жизни.
```

--------------------------------------------------------------------------------------

>14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, т.к.
	перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем.
	Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`.
	Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

__Выполнение__

Команда `tee` в Linux нужна для записи вывода любой команды в один или несколько файлов, указанных
в параметрах, и, одновременно, в `stdout`.

В представленном примере команда `sudo tee` получает на свой вход `sdtin` данные, перенаправленные через `pipe`
из `stdout` команды `echo`. Так как команда `tee` запущена от имени `sudo`, то она имеет права на запись в `new_file`

--------------------------------------------------------------------------------------

## Примечания и восхищения.
	
Отличная статья по теме устройства и работы с потоками ввода\вывода терминала тут: https://selectel.ru/blog/tutorials/linux-redirection/ 

А вот здесь есть очень хорошие примеры перенаправлений:\
https://habr.com/ru/company/ruvds/blog/336320/ \
https://losst.ru/perenapravlenie-vvoda-vyvoda-linux


	В лекции эта часть рассказана мутно и невнятно, в статье - гораздо лучше: понятно, наглядно, с определениями и кучей нюансов.
	Вынес в файл redirections.docx на github.

Ссылка на статью про файловые дескрипторы с примерами: https://habr.com/ru/post/471038/

Всё про утилиту `screen`: https://losst.ru/komanda-screen-linux  \
Помним, что у `screen` есть альтернатива - `tmux`: https://losst.ru/shpargalka-po-tmux

Прекрасная статья про `tee`: https://losst.ru/komanda-tee-linux

reptir... ни одного приличного слова... ru/fv
