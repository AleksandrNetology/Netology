# Работа в терминале. Лекция 2.

#### Стандартные потоки ввода и вывода stdin, stdout, stderr

-stdin - стандартный ввод, условный номер 0. Предназначен для передачи команд и их аргументов в shell: ls -la\
-stdout - стандартный вывод, условный номер 1. Вывод результата работы команды.\
-stderr - стандартный вывод ошибок, условный номер 2. Вывод ошибок возникших при работе команды.

Некоторые команды не выводят никаких сообщений по результату своей работы. Чтобы узнать, об успешности
работы команды надо её об этом спросить: `echo $?` - эта команда выводит код завершения предыдущей команды.
Если 0 - то всё успешно, если 1 - то с ошибкой.

### Файловые дескрипторы.

У каждого открытого файла или процесса есть свой уникальный номер, который ему назначен системой.\
Называется он файловый дескриптор.

Файловые дескрипторы 0, 1, 2 - это и есть те самые уникальные номера, идентификаторы, закреплённые за потоками ввода\вывода.

команда `lsof` показывает список открытых файлов

### Псевдо-файловые системы /dev и /proc

В линуксах существую виртуальные псевдо-файловые системы.\
Пример:

	/dev - файловое представление устройств или драйвера
	/proc - файловое представление структур ядра

По умолчанию они все _read-only_ хотя и есть нюансы.

Базовые операции с этими служебными ФС не отличаются от реальных.\
Например:

	vagrant@netology:~$ ls /proc/upt**
	/proc/uptime
	vagrant@netology:~$ cat /proc/uptime
	23212.21 29807.87

`/proc` содержит довольно много сервисной информации, которая меняется в реальном времени.

`/dev` - тут представлены физические устройства, диски, клавиатура и мышь. Представлены они в виде файлов, драйверов.

Чтобы потестить драйвера можно поставить утилиту [evtest](https://onstartup.ru/utility/evtest/)\
Например, с помощью этой утилиты можно почитать из устройства "клавиатура": `evtest /dev/input/event2`\
Этот выходной поток данных может являтся входным для некой программы.

### Атрибуты процессов: PID

Чтобы воспользоваться командой `lsof` и исследовать потоки данны, нам необходимо знать базовые атрибуты процесса, чтоб к нему обратиться.

	PID - числовой идентификатор процесса, однозначно его определяющий.

Команда `echo $$` - показывает PID текущего процесса.

Если посмотреть содержимое папки /proc/$$ , то можно увидеть все атрибуты этого процесса.
В том числе и файловые дескрипторы данного процесса:

	vagrant@netology:~$ ll /proc/$$/fd/
	total 0
	dr-x------ 2 vagrant vagrant  0 Feb  8 15:01 ./
	dr-xr-xr-x 9 vagrant vagrant  0 Feb  8 15:01 ../
	lrwx------ 1 vagrant vagrant 64 Feb  8 15:01 0 -> /dev/pts/0
	lrwx------ 1 vagrant vagrant 64 Feb  8 15:01 1 -> /dev/pts/0
	lrwx------ 1 vagrant vagrant 64 Feb  8 15:01 2 -> /dev/pts/0
	lrwx------ 1 vagrant vagrant 64 Feb  8 15:25 255 -> /dev/pts/0

echo $PPID покажет родителя данного процесса.

`lsof -p $$` - покажет все открытые файлы текущего процесса.

Среди прочего мы увидим знакомые нам файловые дескрипторы 0, 1 и 2:

	...
	bash    3796 vagrant    0u   CHR  136,0      0t0       3 /dev/pts/0
	bash    3796 vagrant    1u   CHR  136,0      0t0       3 /dev/pts/0
	bash    3796 vagrant    2u   CHR  136,0      0t0       3 /dev/pts/0
	...

Это файловые дескрипторы стандартных ввода и выводов: `stdin, stdout, stderr`

Обращаем внимание, что все эти потоки ссылаются на некую сущность `pts/0`
Т.е. получается, что наш процесс bash смотрит на стандартные потоки ввода\вывода, но они ссылаются
куда-то ещё.

>Обязательно надо помнить, что стандартные потоки ввода\вывода являются __атрибутами__ текущего процесса!

Получается, что у каждого процесса есть такие атрибуты, но они будут свои уникальные.

И вот тут мы вспоминаем про перенаправления ввода\вывода.
Для начала перенаправим оба вывода: `stderr` и `stdout`.

	ls -l /dev/std*
	lrwxrwxrwx 1 root root 15 Feb  8 15:45 /dev/stderr -> /proc/self/fd/2
	lrwxrwxrwx 1 root root 15 Feb  8 15:45 /dev/stdin -> /proc/self/fd/0
	lrwxrwxrwx 1 root root 15 Feb  8 15:45 /dev/stdout -> /proc/self/fd/1

Командой `2>/dev/null` можно перенаправить поток ошибок в никуда :)

Иногда id потоков ввода\вывода можно не указывать.
Например:

	echo $$ > /tmp/log.txt
	эквивалентно
	echo $$ 1> /tmp/log.txt

Еще один частый пример:

	>/tmp/log 2>&1  , что означает: перенаправить stdout в файл /tmp/log, и перенаправить stderr в stdout

Т.е. мы собираем в файл `/tmp/log` одновременно все из `stderr` и `stdout`!

>& - амперсанд, в данном случае, это служебный символ, сообщающий shell, что мы обращаемся к файловому дескриптору, а не к файлу с именем 1.

>При создании перенаправлений очень важен их порядок.

Например, если написать: `2>&1 >/tmp/log` - то будет ошибка.

>Если сначала перенаправить `stderr`, то он будет указывать на текущее значение `stdout {/dev/pts/\*}`,
>т.е. для `stderr` ничего не изменится.

>Все перенаправления устанавливаются shell до начала выполнения программы.

>Нельзя перенаправлять ввод в файл, с которым в тот же момент производятся какие-то манипуляции.

Ещё один пример перенаправления с использованием команды `read`:

	vagrant@vagrant:~$ echo Hello! >ttt	
	vagrant@vagrant:~$ read qqq < ttt
	vagrant@vagrant:~$ echo $qqq
	Hello!

Вообще, классическим примером перенаправления можно считать `pipe` - это когда результат работы команды, т.е. её выход, мы перенаправляем на вход следующего процесса.
Другими словами: с помощью `pipe` мы связываем `stdout` одного процесса с `stdin` другого.

### Наследование файловых дескрипторов.

Как мы уже знаем, при создании новых процессов в линукс, дочерний процесс автоматически получает
от родительского определённый набор свойств.
В этот список входят в точ числе и __открытые__ файловые дескрипторы. Именно по этой причине процессы
которые мы создаём из нашей оболочки (bash) по умолчанию используют те же самые стандартные
потоки, что и оболочка.

[Статья про файловые дескрипторы, потоки ввода\вывода и примеры.](https://habr.com/ru/post/471038/)

### Терминал TTY, эмулятор терминала TTY, псевдо-терминал PTY.

Изначально был физический терминал, устройство для передачи текстовых символов, которое было подключено
через *последовательный* порт к компу. Это устройство и назвали TTY от *TeleTYpewriter*.
Устройство очень поожее на пишущюу машинку - дисплея тогда ещё не придумали.

Помним, что комп изначально был задуман и реализован многопоточным устройством.
Т.е. одновременно у него в памяти выполнялись различные процессы и через TTY им
передавались команды:

{физ. TTY} ---> {поледовательная шина} ---> {драйвер посл.шины} ---> {драйвер tty} ---> {user proc #1}{user proc #2}{user proc #n}

На схеме видим одну пользовательскую сессию с кучей процессов.

Спустя годы появились клавиатуры и мониторы, причём разных производителей, тогда для них придумали драйвера,
чтобы научить их взаимодействию с компом, а `tty` стал существом полностью виртуальным.
Смотрим схему:

			|------------- kernel ----------------------------------------------------------|
	{display} <-----|<--{display driver}<---\							|
			|			 {tty emulator}<-->{line descipline}<-->{tty driver}<-->|<-->{user proc #1}{user proc #2}{user proc #n}
	{keyboard} --->-|-->{keyboard driver}-->/							|
			|-------------------------------------------------------------------------------|

В этой схеме мы говорим о `/dev/ttyX`

Обращаем внимание, что эмулятор терминала реализован непосредственно в ядре ОС, а значит он универсален и не требователен
к ресурсам.

В современном мире, когда доступно очень много аппаратных ресурсов, пользователям стали доступны графические интерфейсы на 
любой вкус и цвет, было принято решение создать в ядре новую версию терминала: псевдо-терминал, `PTY`.

	PTY - это неразделимая пара виртуальных устройств:
		- /dev/ptmx для мастера и
		- /dev/pts/x для слэйва.

Сами драйверы этих виртуальных устройств, как и драйвер `TTY`, работают на уровне ядра ОС, однако если раньше и сам эмулятор терминала
был часть ядра, то теперь это пользовательское приложение, лишь взаимодействующее с мастером `PTY`.


	|----------- kernel -------------
	|	|<------>{/dev/pts/n}<->|<-->{user process}
	|	.			|
	|	.			|
	|	.			|
	|	|<------>{/dev/pts/0}<->|<-->{user process}
	|	|			|
	| {line discipline}		|
	|	|			|
	|	|<------>{/dev/ptmx}<-->|<-->{xterm process}
	|_______________________________|

Как это работает?

Каждый запущенный нами терминал, терминальная сессия, являются виртальными и возникают в виде драйвера в ядре и
уже с ними будет вести взаимодействие наш пользовательский процесс. Терминал запускается в виде слэйва `/dev/pts/x` и 
полностью контролируется мастером `/dev/ptmx`.
Именно такая схема позволила реализовать и концепцию удалённых терминалов, например __SSH__ ( Secury SHell), а так же других
протоколов удалённого взаимодействия.

Фактически, `PTY-slave` продолжает выполнять те же функции, которые ранее выполнял драйвер `TTY`, взаимодействую с
модулем `{line discipline}`. изменилась только схема доставки данных в и из него.
Если раньше данные поставлялись от __аппаратного__ терминала или от __эмулятора__ терминала, то теперь ядро занимается
доставкой данных между `PTY-slave` и `PTY-master`.

#### Взаимодействие псевдо-терминала с системой через графический интерфейс.

При открытии эмулятора терминала в графическом интерфейсе происходит следующее:

1. приложение делает вызовы к __X Windows (X11)__ для отрисовки интерфейса, визуально схожего с оригинальным
	терминалом, но не ограниченным ресурсами ядра: т.е. с любыми эффектами цветности, прозрачности, прокруткой,
	поддержкой системного буфера обмена и т.д.
	
2. начинает "слушать" системные события от Х11, такие, как нажатия клавиатуры.

3. делает специальный вызов к `/dev/ptmx`, создавая парную сессию `/dev/pts/x`

4. события отправляются в мастер `/dev/ptmx`, где вступает в дело `{line discipline}`.

5. полученные из `/dev/ptmx` в ответ данные выводятся в графический интерфейс.

>Т.е. само приложение терминала работает именно с `PTY-master`.

Далее, эмулятор терминала запускает дочерний процесс - *__shell*__ того пользователя, под которым произведён вход
в графическую оболочку системы.
Стандартные потоки ввода\вывода этого *__shell*__ указывают на `/dev/pts/x`, что мы и видели ранее.
Т.о., прямой связи приложения терминала с `std{in,out,err}` *__shell*__ нет.

Можно увидеть, что каждая вкладка в терминале запускает собственную сессию `/dev/pts`: `/dev/pts/0`, `/dev/pts/1`, `/dev/pts/2` и т.д.

Отправляя команды в shell мы видим результат их работы благодаря асинхронному процессу обмена данных между\
`PTY-master` и `PTY-slave`, которым занимается ОС.

Мы всегда можем узнать устройство, с которым ассоциирована наша сессия и увидеть, кто обращался к PTY-master:

```sh
	vagrant@vagrant:~$ tty
	/dev/pts/0
	vagrant@vagrant:~$ lsof /dev/ptmx
	COMMAND     PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
	tmux:\x20 14675 vagrant    8u   CHR    5,2      0t0   88 /dev/ptmx
	tmux:\x20 14675 vagrant    9u   CHR    5,2      0t0   88 /dev/ptmx
	vagrant@vagrant:~$
```

В этот раз `lsof` применён не к запущенному процессу, как мы ранее это делали для дескрипторов shell, а к __устройству__.
Благодаря концепции дескрипторов, есть возможность исследовать одно и то же устройство с разными приложениями:\
драйвер PTY следит за тем, какой процесс сделал вызов к `/dev/ptmx`, поэтому для каждого процесса содержимое по одному
и тому же пути будет разным, как со стандартными потоками.
