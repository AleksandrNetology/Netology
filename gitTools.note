Инструменты Git.

> git log --oneline
> git show <hash> показать содержимое коммита с указанным hash

> git show <branch_name> / <tag> - это вместо хэша можно по названию ветки или метки
> git rev-parse <branch_name> / <tag> - показывает, на какой хэш ссылается объект


-- RefLog - журнал ссылок -----------------------------------------------------------
> git reflog - история, логи всех действий на локальном ПК
> git show HEAD@{5} - показать в логах (reflog) 5й коммит.
> git show main@{yesterday} - последний коммит за вчера из ветки [main]
> git show HEAD@{2.months.ago} - последний коммит 2 месяца назад. Если логи есть, конечно.
> git log -g main - очень подробные логи ветки [main]

! Если был сделан rebase или 'commit --amend', то в reflog можно будет найти
! ссылки на изначальные коммиты по хэшам.



-- Ссылки на предков ----------------------------------------------------------------

> git show <hash>^  - показать первого родителя {значек '^'} указанного хэша
> git show <hash>^2 - показать второго родителя {значек '^2'} указанного хэша

> git show <hash>~  - показать первого родителя указанного хэша
> git show <hash>~2  - показать родителя первого родителя (дедушка) указанного хэша
> git show <hash>~3  - показать родителя родителя первого родителя (прадедушка) указанного хэша
> git show <hash>^^^ 
> git show <hash>~3^2 - комбинации тоже допустимы.


-- Диапазон коммитов ----------------------------------------------------------------

-- две точки --

> git log main..fix
> git log fix..main
Эти две комманды выводят логи всех коммитов между ветками проекта

> git log origin/main..HEAD 
> git log origin/main..
Результат работы этих двух комманд будет одинаков - они показывают разницу между локальной веткой, где установлен указатель HEAD и удалённым репозиторием.
Вместо HEAD можно указать название другой ветки, а если нечего не написать, то git автоматически подставит HEAD 

-- множество точек -- 
Это когда вместо 2х точек используется большее кличество комманд.

Исключение коммитов при помощи --not или ^

Эквивалентные команды. ЭКВИВАЛЕНТНЫЕ!!! :
> git log refA..refB  , где ref* - это название ветки или тэга
> git log ^refA refB - т.е. покажи мне все коммиты, которые есть в refB, но нет в refA
> git log refA --not refB - и здесь тоже самое, что и строкой выше.

Все коммиты, доступные из refA и refB, но не доступные из refС:
> git log refA refB ^refC
> git log refA refB --not refC

-- три точки --

> git log main...fix
 Эта комманда выведет все коммиты, которые есть в каждай ветке отдельно,
 но не в обоих сраду. Т.е. одинаковые для обоих веток коммиты игнорятся.
 
А если сделать вот так:
> git log  --left-right main...fix , то git покажет, к какой ветке какой из коммитов относится.
Что-то типа:
> {c9}
< {c8}
< {c7}
> {c6}


-- интерактивные режимы --

У многих команд есть ключ -i (или --interactive), он позволяет включить интерактивный режим работы в git.
Понятно дело, что интерактивные режимы проще использовать через какие-то утилиты (IDE), но даже в коммандной строке git он есть.
> git add -i , например.


-- Stash и clean ----------------------------------------------------------------

Приберечь и очистить.

Stash нужен в том случае, когда надо переключиться в другую ветку, но свои наработки
пока коммитить рано. Тогда мы и используем >git stash  - сохраняем инменения без
коммита и уходим в другую ветку. Stash сохраняет, прячет изменения в спец. область и
спрятанные таким образом файлы не будут отображаться коммандой >git status

> git stash list - Посмотреть область stash
> git stash apply - возвращает спрятанных файлы в область modified и их снова можно редактировать
					Если часть файлов была в области stage (т.е. к ним была применена комманда git add),
					а часть файлов в области modified, то после выполнения этой комманды все эти файлы
					будут помещены в область modified.
					Если необходимо все файлы из stash вернуть в те области, откуда они были взяты,
					то надо выполнить комманду:
> git stash --index

> git stash drop stash@{0} - удалить stash номер 0.
> git stash pop  - заменяе комманды apply и drop: применить stash и сразу очистить его содержимое.

-----------------
> git stash list
stash@{0} WIP on main: <hash> <filename> in <branch_name> branch
stash@{1} WIP on main: <hash> <filename> in <branch_name> branch
stash@{2} WIP on main: <hash> <filename> in <branch_name> branch

> git stash apply stash@{1}  - применить конкретный stash из списка. Если не указать конкретный номер, то применится последний.
-----------------

И ещё несколько полезных ключей stash.
> git stash --keep-index  - не прятать то, что уже добавлено в индекс коммандой git add
> git stash --include-untracked  - спрятать все неотслеживаемые файлы
> git stash --patch  - интерактивный режим
> git stash branch <branch_name> создать новую ветку из спрятанных изменений

Теперь clean - очистка рабочей директории от ненужных файлов. Как он узнаёт, какие файлы удалять?
С помощью ключа -е, которому мы даём шаблон лоя поиска файлов на удаление.

> git clean -e<шаблон> - сама по себе не выполнится. ОБЯЗАТЕЛЬНО нужны ключи, что ниже. 

-n - ничего не удалять, только показать, что мб удалено;
-f - удалить;
-d - удалять директории;
-q - тихий режим;
-x - удалить даже то, что в директории .gitignore
-i - интерактивный режим.

====== Поиск в git =======================================================================

Поиск осуществляется коммандой git grep.

основные опции:
> git grep -n <что_ищем> - показывает номера строк в файлах, в которых встречается искомое
> git grep -c <что_ищем> - показывает, сколько раз и в каких файлах встречается искомое
> git grep -p <что_ищем> - показывает мотод или функцию, в которой встречается искомое.
							Дело в том, что git знает синтаксис огромного числа языков программирования
							и поэтому понимает, где находятся границы методов и функций.

--and, --or, --not - логические функции применяемые в git grep для уточнения поиска

--break - добавить пустые строки между результатами поиска.							

-- heading - показывает имена файлов над группой найденных строк. Надо проверить, а то херь какая-то.

Пример:
> git grep --break --heading -n -e <что_ищем_1> --and \(-e <что_ищем_2> -e <что_ищем_3>\)v1.0.3
Как это читать: найти что_ищем_1 И либо что_ищем_2 ИЛИ что_ищем_3 в версии v1.0.3 - т.е. он еще и тэги понимает.


-------  Так же поиск можно осуществлять коммандой git log --------------

> git log -S<что_ищем> --oneline - показывает хэши коммитов, в которых искомое появилось или было удалено.

> git log -L :<искомое>:<имя_файла> - поиск изменений тела функции в указанном файле.
										Помним, что git знает огромное количество языков программирования
										и может определить границы функций, а значит и выполнять подобный поиск.
										
Что делать, если git не знает формат языка программирования и не знает, как определить границы функций?
> git log -L '/unsigned longgit_deflate_bound/',/^}/:<имя_файла> - здесь используется регулярное выражение

!Регулярные выражения в git - надо про них прочитать, говорят очень поленая вещь.

------- Бинарный поиск -------------------------------------------------
Бинарный он потому, что делить область поиска всегда примерно на 2 части.
Предназначен для поиска коммитов по принципу плохой-хороший.
Пример такой.
	При тестированиии последнего коммита выясняется, что не работает некий функционал.
	Причём мы знаем, что несколько коммитов назад всё было хорошо.
	Как найти тот коммит, изменения которого сломали функционал?
	Бинарный поиск!
> git bisect start  - запускаем бинарный поиск
> git bisect bad  - отмечаем плохим коммитом текущий. Т.е. в нём не работает функционал
> git bisect good v1.0.2 - метка коммита, где функционал работает.

	Здесь бинарный поиск нам сообщает, что между плохим и хорошим коммитами N-коммитов
	и перебрасывает нас на тот, что находится примерно по середине между чтоками bad-good.
	Выясняем с помощью тестов, текущий коммит bad или good и сообщаем его статус git 
	с помощью очередной комманды git bisect bad\good, после чегоцикл повторяется.
	
	После обнаружения искомого, поиск нужно завершить:
> git bisect reset


Бинарный поиск можно автоматизировать, указав ему в качетве аргумента скрипт,
с помощью которого он сам сможет тестировать коммиты на bad\good.

Пример:
>git bisect start HEAD v0.1.2  - стартуем, указывая сразу bad и good коммиты
>git bisect run test_script.sh - скрипт автотестирования, тестирующий коммиты и отмечающий их как bad\good
 
Если тест завершается с кодом выхода ноль - это good-коммит, а если код выхода любой другой - то bad.

------------------------




