Инструменты Git.

> git log --oneline
> git show <hash> показать содержимое коммита с указанным hash

> git show <branch_name> / <tag> - это вместо хэша можно по названию ветки или метки
> git rev-parse <branch_name> / <tag> - показывает, на какой хэш ссылается объект


-- RefLog - журнал ссылок -----------------------------------------------------------
> git reflog - история, логи всех действий на локальном ПК
> git show HEAD@{5} - показать в логах (reflog) 5й коммит.
> git show main@{yesterday} - последний коммит за вчера из ветки [main]
> git show HEAD@{2.months.ago} - последний коммит 2 месяца назад. Если логи есть, конечно.
> git log -g main - очень подробные логи ветки [main]

! Если был сделан rebase или 'commit --amend', то в reflog можно будет найти
! ссылки на изначальные коммиты по хэшам.



-- Ссылки на предков ----------------------------------------------------------------

> git show <hash>^  - показать первого родителя {значек '^'} указанного хэша
> git show <hash>^2 - показать второго родителя {значек '^2'} указанного хэша

> git show <hash>~  - показать первого родителя указанного хэша
> git show <hash>~2  - показать родителя первого родителя (дедушка) указанного хэша
> git show <hash>~3  - показать родителя родителя первого родителя (прадедушка) указанного хэша
> git show <hash>^^^ 
> git show <hash>~3^2 - комбинации тоже допустимы.


-- Диапазон коммитов ----------------------------------------------------------------

-- две точки --

> git log main..fix
> git log fix..main
Эти две комманды выводят логи всех коммитов между ветками проекта

> git log origin/main..HEAD 
> git log origin/main..
Результат работы этих двух комманд будет одинаков - они показывают разницу между локальной веткой, где установлен указатель HEAD и удалённым репозиторием.
Вместо HEAD можно указать название другой ветки, а если нечего не написать, то git автоматически подставит HEAD 

-- множество точек -- 
Это когда вместо 2х точек используется большее кличество комманд.

Исключение коммитов при помощи --not или ^

Эквивалентные команды. ЭКВИВАЛЕНТНЫЕ!!! :
> git log refA..refB  , где ref* - это название ветки или тэга
> git log ^refA refB - т.е. покажи мне все коммиты, которые есть в refB, но нет в refA
> git log refA --not refB - и здесь тоже самое, что и строкой выше.

Все коммиты, доступные из refA и refB, но не доступные из refС:
> git log refA refB ^refC
> git log refA refB --not refC

-- три точки --

> git log main...fix
 Эта комманда выведет все коммиты, которые есть в каждай ветке отдельно,
 но не в обоих сраду. Т.е. одинаковые для обоих веток коммиты игнорятся.
 
А если сделать вот так:
> git log  --left-right main...fix , то git покажет, к какой ветке какой из коммитов относится.
Что-то типа:
> {c9}
< {c8}
< {c7}
> {c6}


-- интерактивные режимы --

У многих команд есть ключ -i (или --interactive), он позволяет включить интерактивный режим работы в git.
Понятно дело, что интерактивные режимы проще использовать через какие-то утилиты (IDE), но даже в коммандной строке git он есть.
> git add -i , например.


-- Stash и clean ----------------------------------------------------------------

Приберечь и очистить.

Stash нужен в том случае, когда надо переключиться в другую ветку, но свои наработки
пока коммитить рано. Тогда мы и используем >git stash  - сохраняем инменения без
коммита и уходим в другую ветку. Stash сохраняет, прячет изменения в спец. область и
спрятанные таким образом файлы не будут отображаться коммандой >git status

> git stash list - Посмотреть область stash
> git stash apply - возвращает спрятанных файлы в область modified и их снова можно редактировать
					Если часть файлов была в области stage (т.е. к ним была применена комманда git add),
					а часть файлов в области modified, то после выполнения этой комманды все эти файлы
					будут помещены в область modified.
					Если необходимо все файлы из stash вернуть в те области, откуда они были взяты,
					то надо выполнить комманду:
> git stash --index

> git stash drop stash@{0} - удалить stash номер 0.
> git stash pop  - заменяе комманды apply и drop: применить stash и сразу очистить его содержимое.

-----------------
> git stash list
stash@{0} WIP on main: <hash> <filename> in <branch_name> branch
stash@{1} WIP on main: <hash> <filename> in <branch_name> branch
stash@{2} WIP on main: <hash> <filename> in <branch_name> branch

> git stash apply stash@{1}  - применить конкретный stash из списка. Если не указать конкретный номер, то применится последний.
-----------------

И ещё несколько полезных ключей stash.
> git stash --keep-index  - не прятать то, что уже добавлено в индекс коммандой git add
> git stash --include-untracked  - спрятать все неотслеживаемые файлы
> git stash --patch  - интерактивный режим
> git stash branch <branch_name> создать новую ветку из спрятанных изменений

Теперь clean - очистка рабочей директории.

> git clean - сама по себе не выполнится. ОБЯЗАТЕЛЬНО нужны ключи.

-n - ничего не удалять, только показать, что мб удалено;
-f - удалить;
-d - удалять директории;
-q - тихий режим;
-x - удалить даже то, что в директории .gitignore
-i - интерактивный режим.

