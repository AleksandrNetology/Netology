Продвинутся мерж.

-- Прерывание слияния (merge) --

> git merge <branch_name> - пытаемся слить, мерж, ветку branch_name на текущую (main, например).

Предположим, что и в основной ветке main и в нашей branch_name, изменили один и тот же файл, одни и те
же строчки одного и того же файла. Тогда при мерже произойдёт конфликт.
Можно решить его, методом редактирования конфликтов, но можно и отменить мерж:

> git merge --abort - останавливаем, прерываем выполнение опреации
или
> git reset --hard HEAD - сброс мержа, и возвращение HEAD на тот коммит, где он и стоял до попытки слияния


-- Игнорирование символов пробела --

Проблема возникает, когда разные люди работают над одним и тем же файлом, но разными методами: для форматирования
текста кто-то вставляет знаки табуляции, кто-то знаки пробелов, а кто-то их смесь. При мерже возникнет проблема
симоволов пробела.

Для того, чтобы это обойти эту проблему, у git merge есть специальный способ:
> git merge -Xignore-all-space whilespace

! Описание, традиционно, в git merge --help? прочитать про ключ '-X' и стратегии, они начинаются на 'ignore-'



-- Ручное слияние --

Предположим, что конфликт при мерже уже произошёл и нам надо его решить.

> git show - команда, показывающая инфу по любому объекту из базы git

Итак:
> git show :1:file_name > file_name_common  - указываем файл до слияния, находящийся в основной ветке.
> git show :2:file_name > file_name_01  - файл в той ветке, где мы сейчас 
> git show :3:file_name > file_name_02  - файл ветки, которую мы хотим слить.

Далее, командой 
> git ls-files -u  - смотрим хэши всех файлов, находящихся в состоянии конфликта
100644 <hash 1> 1 file_name  
100644 <hash 2> 2 file_name
100644 <hash 3> 3 file_name

т.е. мы можем видеть, что сокращение ":1:file_name" - это и есть ссылка на хэш указанного файла. ХЗ зачем нам это.

Далее, отправляемся в наш любимый редактор для правок перед мержем и начинаем вносить необходимые исправления.
Внеся исправления, повторно пробуем выполнить слияние с помощью команды git merge-file:
> git merge-file -p <file_name_01> <file_name_common> <file_name_02> > file_summ  

Она покажет, в каких файлах какие конфликты, покажет, как она будет сливать файлы.


Так же перед коммитом можно посмотреть различия между состояниями при помощи комманды  git diff

> git diff --ours    - показывает разницу текущего состояния конфликта с состоянием до него.
> git diff --theirs  - обратное --ours
> git diff --base    - показывает состояние до мержа

! Смотрим git diff --help и охреневаем от возможностей. Например, при мерже можно сказать, чтоб игнорились те или иные символы.

Не забываем выполнять git clean -f для очистки текущей директории от ненужных файлов.


-- Checkout в конфликтах --

> git checkout --conflict=merge <file_name>  - вернуть файл в состояние конфликта
> git checkout --conflict=diff3 <file_name>  - показать три состояния файла при 3х стороннем слиянии


-- История при слиянии --

> git log --oneline --left-fight HEAD...MERGE_HEAD  , где HEAD - это состояние до конфликта,
														а MERGE_HEAD - это текущее состояние.
														
С помощью символов > и < git нам покажет, какой из коммито от какой ветки к нам пришёл. Возможно удасться
по комменту к коммитам понять, что именно могло вызвать состояние конфликта. Вот почему нужны информативные
коментарии.

> git log --left-fight --merge  - покажет нам только те коммиты, в которых менялся конфликтующий файл


-- Rerere (reuse recorded resolution) --
Повторное использование сохранённых разрешений конфликтов.
Может понадобится для автоматизации.

Включение этой системы позволяет научить git разрешать некоторые части конфликтов.
Получается, что если периодически возникает один и тот же конфликт, git сможет разрешить его автоматически.

Включить: 
> git config --global rerere.enabled true

Вещь редко нужная.


------ Опция blame ------
Она позволяет найти виновного.

> git blame -L 12,16 file_name  - показать мне строчки с 12 по 16 файла file_name
Выводом этой команды будут заданные строчки файла и, что важно, будет указано имя пользователя, создавшего эти строчки.

Если же мы добавим опцию -С , то git попытается отыскать ещё и первоисточник фрагмента:
> git blame -С -L 12,16 file_name
Знак '^' означает, что этот коммит и есть изначальный источник строк.
